TMP_DIR='/Users/ram/Downloads/small_krs/train/fv01'

#파일 다운받기
files=sorted(glob(os.path.join(TMP_DIR, '*.wav')))
target_text =sorted(glob(os.path.join(TMP_DIR, '*.txt')))

#text 문장에서 고칠거 고치기
def target():
    for i in range(0, len(target_text)):
        with open(target_text[i], 'rt', encoding='UTF8') as f:
            line=f.readlines()
            line=str(line)
    # Get only the words between [a-z] and replace period for none
            original = ' '.join(line.strip().lower().split(' ')[2:]).replace('.', '')
            targets = original.replace(' ', '  ')
            targets = targets.split(' ')

# Adding blank label
            targets = np.hstack([SPACE_TOKEN if x == '' else list(x) for x in targets])
# Transform char into index
            targets = np.asarray([SPACE_INDEX if x == SPACE_TOKEN else ord(x) - FIRST_INDEX for x in targets])
            train_targets = sparse_tuple_from([targets])
    return train_targets

train_targets=target()

#audio를 mfcc로 변환하기
def audio_only(f):
    return [sf.read(audio_path)for audio_path in f]
audio=audio_only(files)

#mfcc
def mfcc_list(audio):
    return [mfcc(audio[i][0], audio[i][1]) for i in range(0,len(audio))]
mfcc=mfcc_list(audio)

def func(x):
    a=[]
    result=[]
    for i in range(0, len(x)):
        train_inputs = (np.asarray(x[i][np.newaxis,:]) - np.mean(np.asarray(x[i][np.newaxis,:])))/np.std(np.asarray(x[i][np.newaxis,:]))
        train_seq_len = [train_inputs.shape[1]]
        a=[train_inputs, train_seq_len]
        result.append(a)
    return result
train=func(mfcc)